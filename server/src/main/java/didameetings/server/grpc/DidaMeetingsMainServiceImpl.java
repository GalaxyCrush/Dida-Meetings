package didameetings.server.grpc;

/* these imported classes are generated by the contract */

import didameetings.DidaMeetingsMain;
import didameetings.DidaMeetingsMainServiceGrpc;
import didameetings.server.commands.DidaMeetingsAction;
import didameetings.server.commands.DidaMeetingsCommand;
import didameetings.server.core.DidaMeetingsServerState;
import didameetings.server.core.PendingTopicOperation;
import didameetings.server.core.RequestRecord;
import io.grpc.stub.StreamObserver;

public class DidaMeetingsMainServiceImpl extends DidaMeetingsMainServiceGrpc.DidaMeetingsMainServiceImplBase {

    DidaMeetingsServerState server_state;

    public DidaMeetingsMainServiceImpl(DidaMeetingsServerState state) {
        this.server_state = state;
    }

    @Override
    public void open(DidaMeetingsMain.OpenRequest request,
            StreamObserver<DidaMeetingsMain.OpenReply> responseObserver) {

        if (!checkDebug(responseObserver))
            return;

        // for debug purposes
        System.out.println("Receiving open request:" + request);

        int reqid = request.getReqid();
        int mid = request.getMeetingid();

        // for debug purposes
        System.out.println("reqid " + reqid + " meetingid " + mid);

        DidaMeetingsCommand command = new DidaMeetingsCommand(DidaMeetingsAction.OPEN, mid);

        // for debug purposes
        System.out.println("Adding open request with reqid " + reqid + " to pending");

        RequestRecord request_record = new RequestRecord(reqid, command);
        this.server_state.getReq_history().addToPending(reqid, request_record);
        this.server_state.getMain_loop().wakeup();
        boolean result = request_record.waitForResponse();

        // for debug purposes
        System.out.println("Result is ready for open request with reqid " + reqid);

        DidaMeetingsMain.OpenReply response = DidaMeetingsMain.OpenReply.newBuilder().setReqid(reqid).setResult(result)
                .build();
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void add(DidaMeetingsMain.AddRequest request, StreamObserver<DidaMeetingsMain.AddReply> responseObserver) {

        if (!checkDebug(responseObserver))
            return;

        // for debug purposes
        System.out.println("Receiving add request:" + request);

        int reqid = request.getReqid();
        int mid = request.getMeetingid();
        int pid = request.getParticipantid();

        // for debug purposes
        System.out.println("reqid " + reqid + " meetingid " + mid + " participantid " + pid);

        DidaMeetingsCommand command = new DidaMeetingsCommand(DidaMeetingsAction.ADD, mid, pid);

        // for debug purposes
        System.out.println("Adding add request with reqid " + reqid + " to pending");

        RequestRecord request_record = new RequestRecord(reqid, command);
        this.server_state.getReq_history().addToPending(reqid, request_record);
        this.server_state.getMain_loop().wakeup();
        boolean result = request_record.waitForResponse();

        // for debug purposes
        System.out.println("Result is ready for add request with reqid " + reqid);

        DidaMeetingsMain.AddReply response = DidaMeetingsMain.AddReply.newBuilder().setReqid(reqid).setResult(result)
                .build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void topic(DidaMeetingsMain.TopicRequest request,
            StreamObserver<DidaMeetingsMain.TopicReply> responseObserver) {

        if (!checkDebug(responseObserver))
            return;

        // for debug purposes
        System.out.println("Receiving topic request:" + request);

        int reqid = request.getReqid();
        int mid = request.getMeetingid();
        int pid = request.getParticipantid();
        int topic = request.getTopicid();

        // for debug purposes
        System.out.println("reqid " + reqid + " meetingid " + mid);

        boolean result = false;
        DidaMeetingsMain.TopicReply response;
        if (canExecuteTopicNow(mid, pid)) {
            result = executeTopicDirectly(mid, pid, topic);

            response = DidaMeetingsMain.TopicReply.newBuilder()
                    .setReqid(reqid)
                    .setResult(result)
                    .build();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;
        }

        PendingTopicOperation op = new PendingTopicOperation(reqid, topic, mid, pid, responseObserver);
        this.server_state.addPendingTopicOperation(op);
        response = DidaMeetingsMain.TopicReply.newBuilder()
                    .setReqid(reqid)
                    .setResult(result)
                    .build();
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void close(DidaMeetingsMain.CloseRequest request,
            StreamObserver<DidaMeetingsMain.CloseReply> responseObserver) {

        if (!checkDebug(responseObserver))
            return;

        // for debug purposes
        System.out.println("Receiving close request:" + request);

        int reqid = request.getReqid();
        int mid = request.getMeetingid();

        // for debug purposes
        System.out.println("reqid " + reqid + " meetingid " + mid);

        DidaMeetingsCommand command = new DidaMeetingsCommand(DidaMeetingsAction.CLOSE, mid);

        // for debug purposes
        System.out.println("Adding close request with reqid " + reqid + " to pending");

        RequestRecord request_record = new RequestRecord(reqid, command);
        this.server_state.getReq_history().addToPending(reqid, request_record);
        this.server_state.getMain_loop().wakeup();
        boolean result = request_record.waitForResponse();

        // for debug purposes
        System.out.println("Result is ready for close request with reqid " + reqid);

        DidaMeetingsMain.CloseReply response = DidaMeetingsMain.CloseReply.newBuilder().setReqid(reqid)
                .setResult(result).build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void dump(DidaMeetingsMain.DumpRequest request,
            StreamObserver<DidaMeetingsMain.DumpReply> responseObserver) {

        if (!checkDebug(responseObserver))
            return;

        // for debug purposes
        System.out.println("Receiving dump request:" + request);

        int reqid = request.getReqid();

        // for debug purposes
        System.out.println("reqid " + reqid);

        DidaMeetingsCommand command = new DidaMeetingsCommand(DidaMeetingsAction.DUMP);

        // for debug purposes
        System.out.println("Adding dump request with reqid " + reqid + " to pending");

        RequestRecord request_record = new RequestRecord(reqid, command);
        this.server_state.getReq_history().addToPending(reqid, request_record);
        this.server_state.getMain_loop().wakeup();
        boolean result = request_record.waitForResponse();

        // for debug purposes
        System.out.println("Result is ready for dump request with reqid " + reqid);

        DidaMeetingsMain.DumpReply response = DidaMeetingsMain.DumpReply.newBuilder().setReqid(reqid).setResult(result)
                .build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    /**
     * Checks the current debug mode and applies the corresponding behavior
     * - if frozen, sends an UNAVAILABLE error to the client
     * - if slow, introduces a delay before continuing
     * - if crash, the process has already exited
     * - else proceeds normally
     *
     * @param responseObserver the gRPC response observer used to notify the client
     *                         in case of freeze
     * @return true if normal processing should continue, false if the request must
     *         be aborted
     */
    private boolean checkDebug(StreamObserver<?> responseObserver) {
        try {
            server_state.applyDebugBehavior(); // May block if frozen
            return true;
        } catch (RuntimeException e) {
            // Only returns false if an actual error occurs (e.g., crash)
            return false;
        }
    }

    private boolean canExecuteTopicNow(int mid, int pid) {
        return server_state.getMeeting_manager().getMeeting(mid) != null
                && server_state.getMeeting_manager().getMeeting(mid).getParticipant(pid) != null;
    }

    private boolean executeTopicDirectly(int mid, int pid, int topicid) {
        return server_state.getMeeting_manager().setTopic(mid, pid, topicid);
    }

}
